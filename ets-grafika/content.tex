\section{File HTML}

\subsection*{Setup Canvas}

\begin{lstlisting}[language=html, label={lst: indexHtml}, caption={file index.html}]
<html lang="en">
  <head>
    <title>ETS</title>
    <meta charset="utf-8" />
  </head>
  <body onload="startup();">
    <canvas id="canvas" width="500" height="500"></canvas>

    <div style="position: absolute; top: 550px; color: black; z-index: 10">
      Keyboard:
      <ul>
        <li>W untuk maju</li>
        <li>S untuk mundul</li>
        <li>D untuk rotate ke kanan</li>
        <li>A untuk rotate ke kiri</li>
        <li>panah atas untuk ke atas (max. 20)</li>
        <li>panah bawah untuk ke bawah (min.0)</li>
      </ul>
    </div>
    
\end{lstlisting}

Melakukan inisiasi \textit{canvas} pada html dengan cara melakukan \lstinline[language=html]{<canvas id="canvas" width="500" height="500"></canvas>}. Selain itu, juga dilakukan pemanggilan fungsi \texttt{startup()} pada saat file html sudah terload sepenuhnya.

\subsection*{Setup Vertex Shader}

\begin{lstlisting}[language=html, label={lst: vertexShader}, caption={file vertexShader}]
    <script id="vs-src" type="x-shader/x-vertex">
      attribute vec3 aVertexPosition;
      attribute vec4 aVertexColor;

      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;

      varying vec4 vColor;

      void main(void) {
          gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);
          vColor = aVertexColor;
      }
    </script>

\end{lstlisting}

Nantinya, setiap vertex yang dikirimkan ke vertexShader akan dikalikan dengan \texttt{uProjectionMatrix} yang digunakan untuk memposisikan menentukan bagaimana behaviour "kamera" dalam scene. Selanjutnya, akan mengalami proses perkalian dengan \texttt{uModelViewMatrix} yang berfungsi untuk menentukan lokasi model dalam koordinat global.

\subsection*{Setup Fragment Shader}

\begin{lstlisting}[language=html, label={lst: fragmentShader}, caption={file fragmentShader}]
    <script id="fs-src" type="x-shader/x-fragment">
      precision mediump float;

      varying vec4 vColor;

      void main(void) {
          gl_FragColor = vColor;
      }
    </script>

\end{lstlisting}

FragmentShader akan digunakan untuk menentukan warna model yang akan ditampilkan di layar.

\subsection*{Load Script yang Dibutuhkan}

\begin{lstlisting}[language=html, label={lst: neccessary script}, caption={file Load Script}]
    <script src="gl-matrix-min.js"></script>
    <script type="text/javascript" src="utils.js"></script>
    <script type="text/javascript" src="initShader.js"></script>
    <script type="text/javascript" src="index.js"></script>
  </body>
</html>
\end{lstlisting}

Disini dilakukan beberapa load script - script yang akan digunakan dalam program nantinya. \texttt{gl-matrix-min.js} digunakan untuk mempermudah penghitungan matrix orde 3 dan 4 yang akan digunakan saat melakukan animasi. \texttt{utils.js} berisi beberapa fungsi penting seperti \texttt{loadWebglContext} yang digunakan untuk mendapatkan context webGL sebelum kita dapat menampilkan objek apapun. \texttt{initShader.js} digunakan untuk melakukan compile terhadap vertexShader dan fragmentShader. Dan \texttt{index.js} merupakan file utama yang paling penting karena berisi merupakan tempat fungsi \texttt{startup} berada

\section{File Utils.js}

Terdapat beberapa fungsi penting di file \texttt{utils.js} ini,

\begin{itemize}
  \item \textbf{createGLContext}

        Berfungsi untuk mendapatkan webGL context yang akan dipakai di seluruh bagian \texttt{index.js} nantinya.

  \item \textbf{getShaderfromDOM}

        Mendapatkan ShaderSource baik itu adalah vertexShader maupun fragmentShader dari file \texttt{index.html} yang sudah dibuat sebelumnya.

  \item \textbf{createSphere}

        Menghitung vertex yang akan digunakan untuk membentuk suatu model sphere.


        \begin{lstlisting}[language=javascript, label={lst: createSphere}, caption={fungsi createSphere}]
function createSphere(div, color) {
  var positions = [];
  for (var i = 0; i <= div; ++i) {
    var ai = (i * Math.PI) / div;
    var si = Math.sin(ai);
    var ci = Math.cos(ai);
    for (var j = 0; j <= div; ++j) {
      var aj = (j * 2 * Math.PI) / div;
      var sj = Math.sin(aj);
      var cj = Math.cos(aj);
      positions = positions.concat([si * sj, ci, si * cj]);
    }
  }

  var indices = [];
  for (var i = 0; i < div; ++i) {
    for (var j = 0; j < div; ++j) {
      var p1 = i * (div + 1) + j;
      var p2 = p1 + (div + 1);
      indices = indices.concat([p1, p2, p1 + 1, p1 + 1, p2, p2 + 1]);
    }
  }

  var colors = [];
  for (var i = 0; i != indices.length; i++) {
    colors = colors.concat(color);
  }

  return {
    vertexData: positions,
    indices: indices,
    colors: colors,
  };
}

\end{lstlisting}

\end{itemize}

\section{File initShader.js}

File ini digunakan untuk melakukan load terhadap shader dari ShaderSource menjadi WebGLProgram. fungsi \texttt{loadShader} merupakan fungsi untuk melakukan compile shaderSource untuk kemudian agar bisa dilakukan \texttt{gl.attachShader} dalam webGL. Berikut adalah salah satu fungsi yang ada di file \texttt{initShader.js}.


\begin{lstlisting}[language=javascript, label={lst: setupShader}, caption={fungsi setupShader}]
function setupShaders(gl, vertexSource, fragmentSource) {
  var vertextShader = loadShader(gl, gl.VERTEX_SHADER, vertexSource);
  var fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fragmentSource);

  shaderProgram = gl.createProgram();
  gl.attachShader(shaderProgram, vertextShader);
  gl.attachShader(shaderProgram, fragmentShader);
  gl.linkProgram(shaderProgram);

  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
    console.error("failed to setup shaders");
  }

  return shaderProgram;
}

\end{lstlisting}

\section{File index.js}

File ini adalah backbone utama dari project WebGL ini, berisi konfigurasi viewport webgl, object modelling, object animation dan banyak lagi.

\subsection*{data planet}

Untuk memudahkan dalam pengembangan, saya memutuskan untuk menyatukan konfigurasi planet - planet yang akan di render dalam scene. Dengan cara memisahkan antara konfigurasi planet dengan cara menggambar nantinya akan memudahkan saat proses debugging.

\begin{lstlisting}[language=javascript, label={lst: dataPlanet}, caption={list data planet}]
  {
    color: [1, 0.97, 0.19, 1.0],
    translation: [0, 0, 0],
    rotation: 0.01,
    scale: 1,
    hasChild: true,
    parentId: -1,
  }
  
\end{lstlisting}

Potongan kode \ref{lst: dataPlanet} adalah salah satu data planet yang digunakan, untuk keterangannya adalah :

\begin{itemize}
  \item \textbf{color}, menyimpan value warna planet
  \item \textbf{translation}, menyimpan lokasi koordinat lokal planet
  \item \textbf{rotation}, kecepatan rotasi dan kecepatan planet memutari parentnya
  \item \textbf{scale}, ukuran planet, hal ini karena fungsi \texttt{createSphere} di potongan kode \ref{lst: createSphere} hanya membuat sphere dengan ukuran radius 1.0.
  \item \textbf{hasChild}, sebuah boolean value untuk menunjukkan apakah suatu planet memiliki child dalam hierarki
  \item \textbf{parentId}, menyimpan id parent yang akan digunakan dalam hierarki
\end{itemize}
